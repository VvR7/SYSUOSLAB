# 2025年春季中山大学OS实验
cpf老师实验班
环境配置：配置Linux虚拟机，或在Windows下配置WSL2
# 目录
- [Lab1:配置环境](#Lab1)
- [Lab2:实模式](#Lab2)
- [Lab3:保护模式](#Lab3)
- [Lab4:中断](#Lab4)
- [Lab5:线程](#Lab5)
- [Lab6:锁与信号量](#Lab6)
- [Lab7:内存管理](#Lab7)
- [Lab8:进程](#Lab8)
- [Lab9:扩展](#Lab9)
## Lab1
- 搭建OS内核开发环境包括：代码编辑环境、编译环境、运行环境、调试环境等。
- 下载并编译i386（32位）内核，并利用qemu启动内核。
- 熟悉制作initramfs的方法。
- 编写简单应用程序随内核启动运行。
- 编译i386版本的Busybox，随内核启动，构建简单的OS。
- 开启远程调试功能，进行调试跟踪代码运行。
## Lab2
### 实验任务

本次实验包括4个assignment，请大家仔细阅读README.md文件后完成实验。

**请注意，今年的实验有部分改动，与往年不一样，请大家千万不要抄袭往年的代码；如果使用大模型写的代码，也请务必标注出来，老师和助教会有查重，以避免抄袭行为！**

实验的DDL是 2025.03.25 23:59

#### 提交内容

将**4个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab2-姓名-学号**”，并交到[课程网站](http://course.dds-sysu.tech/course/18/homework)上。

#### Assignment 1 MBR

> 注意，assignment 1的寄存器请使用16位的寄存器。

#####  1.1

复现example 1。说说你是怎么做的，并将结果截图。

##### 1.2

请修改example 1的代码，使得MBR被加载到0x7C00后在(16,10)处开始输出你的学号。注意，你的学号显示的前景色和背景色必须和教程中不同。说说你是怎么做的，并将结果截图。

#### Assignment 2 实模式中断

参考资料如下。

- [OSDev 关于 BIOS 的介绍](https://wiki.osdev.org/BIOS)
- [BIOS 中断表](http://www.ctyme.com/rbrown.htm)
- [VIDEO - WRITE CHARACTER ONLY AT CURSOR POSITION](http://www.ctyme.com/intr/rb-0100.htm)
- [VIDEO - WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION](http://www.ctyme.com/intr/rb-0099.htm)
- [VIDEO - WRITE STRING (AT and later,EGA)](http://www.ctyme.com/intr/rb-0210.htm)
- [VIDEO - GET CURSOR POSITION AND SIZE](http://www.ctyme.com/intr/rb-0088.htm)
- [10h中断](https://zh.wikipedia.org/wiki/INT_10H)

2.1和2.2使用的都是实模式中断`int 10h`，由于功能号不同，执行的结果也就不同。在[`int 10h`中断的资料](https://zh.wikipedia.org/wiki/INT_10H) 中，其只给出10h中断下各个功能号的用途，并未给出实际的用法。因此，同学们可能一开始会感觉不知所云，教程下面给出同学们完成本次实验需要用到的功能号。

| 功能                       | 功能号 | 参数                                         | 返回值                                           |
| -------------------------- | ------ | -------------------------------------------- | ------------------------------------------------ |
| 设置光标位置               | AH=02H | BH=页码，DH=行，DL=列                        | 无                                               |
| 获取光标位置和形状         | AH=03H | BX=页码                                      | AX=0，CH=行扫描开始，CL=行扫描结束，DH=行，DL=列 |
| 在当前光标位置写字符和属性 | AH=09H | AL=字符，BH=页码，BL=颜色，CX=输出字符的个数 | 无                                               |

注意，“页码”均设置为0。

一般地，中断的调用方式如下。

```
将参数和功能号写入寄存器
int 中断号
从寄存器中取出返回值
```

##### 2.1

请探索实模式下的光标中断，**利用中断实现光标的位置获取和光标的移动**。说说你是怎么做的，并将结果截图。

##### 2.2

请修改1.2的代码，**使用实模式下的中断来输出你的学号**。说说你是怎么做的，并将结果截图。

##### 2.3

在2.1和2.2的知识的基础上，探索实模式的键盘中断，**利用键盘中断实现键盘输入并回显**，可以参考[该资料](https://blog.csdn.net/deniece1/article/details/103447413)。关于键盘扫描码，可以参考[该资料](http://blog.sina.com.cn/s/blog_1511e79950102x2b0.html)。说说你是怎么做的，并将结果截图。

#### Assignment 3 汇编

> - assignment 3的寄存器请使用32位的寄存器。
> - 首先执行命令`sudo apt install gcc-multilib g++-multilib`安装相应环境。
> - **你需要实现的代码文件在`assignment/student.asm`中。**
> - 编写好代码之后，在目录`assignment`下**使用命令`make run`即可测试**，不需要放到mbr中使用qemu启动。
> - `a1`、`if_flag`、`my_random`等都是预先定义好的变量和函数，直接使用即可。
> - 你可以修改`test.cpp`中的`student_setting`中的语句来得到你想要的`a1`。（请尽可能多测试几组样例，以有充分的理由说明你的代码是对的）
> - 最后附上`make run`的截图，并说说你是怎么做的。

##### 3.1 分支逻辑的实现

请将下列伪代码转换成汇编代码，并放置在标号`your_if`之后。

```
if a1 >= 40 then
	if_flag = (a1 + 3) / 5
else if a1 >= 18 then
	if_flag = 80 - (a1 * 2)
else
	if_flag = a1 << 5
end
```

> 特别提醒，在使用除法的时候，你可能会遇到浮点数异常报错，请自行查询资料，了解`idiv`指令的用法。

##### 3.2 循环逻辑的实现

请将下列伪代码转换成汇编代码，并放置在标号`your_while`之后。

```
while a2 < 25 then
	call my_random        // my_random将产生一个随机数放到eax中返回
	while_flag[a2 * 2] = eax
	++a2
end
```

##### 3.3 函数的实现

请编写函数`your_function`并调用之，函数的内容是遍历字符数组`your_string`。

```
your_function:
	for i = 0; your_string[i] != '\0'; ++i then
		pushad
		push (your_string[i] + 9) to stack
		call print_a_char
		pop stack
		popad
	end
	return
end
```

#### Assignment 4 汇编小程序

必做：字符回旋程序。请你用汇编代码实现一个字符回旋程序，使其能够在qemu显示屏上面，以不同的颜色、字符内容进行顺时针绕圈（见下图）。请注意，对于这个绕圈的字符，你还需要考虑他的运动速度，不要让其运动过快（可自行查阅其他资料，采用合适的中断来实现延时效果）

![字符回旋程序](./gallery/字符回旋程序-1.png)

选做1：如果你认为该任务太简单，你还可以实现一个不断向内绕圈的字符（见下图）。请注意，你需要设置一个期限，不能让他无休止地向内绕圈，导致访问非法内存。

![字符回旋程序](./gallery/字符回旋程序-2.png)


选做2：如果你还想在这个任务上完一些花活，你可以结合Assignment 2中的读取键盘输入，来实现一个简单的贪吃蛇，不必做出糖果和吃糖果，只需要绘制出一条会根据用户输入而进行上下左右运动的蛇即可。

> 在这个任务中，你可能会面临寄存器不足的问题，请你思考一下，你可以通过什么方法来解决这个问题。（可以将该题作为额外思考题写到报告上，同时也可以辅以一些实验来说明）



### 实验概述

在第一章中，同学们会学习到x86汇编、计算机的启动过程、IA-32处理器架构和字符显存原理。根据所学的知识，同学们能自己编写程序，然后让计算机在启动后加载运行，以此增进同学们对计算机启动过程的理解，为后面编写操作系统加载程序奠定基础。同时，同学们将学习如何使用gdb来调试程序的基本方法。

### 参考资料

- [x86汇编(Intel汇编)入门](https://www.cnblogs.com/jiftle/p/8453106.html)
- 《Intel汇编语言程序设计》第1-8章
- 《从实模式到保护模式》第1-8章

希望使用 UEFI 结合 C++ 或 Rust 进行操作系统开发的同学，请参考[UEFI 的相关指引](./uefi.md)。下面的指引是基于 MBR 引导、汇编结合 C++ 进行开发的。

## Lab3
### Lab3 保护模式

### 实验要求

> - DDL：2025年4月8号 23:59:59
> - 提交的内容：将**3个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab3-姓名-学号.zip**”，并交到[课程网站上](http://course.dds-sysu.tech/course/18/homework)
> - **材料的Example的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

**本次实验中，代码要求并不高（主要为复现任务），主要希望同学们掌握保护模式、段地址的知识，同时学习gdb调试的方法，并在调试的过程中，学习到操作系统内核的知识与注意事项。**



#### Assignment 1

##### 1.1

复现Example 1，说说你是怎么做的并提供结果截图，也可以参考Ucore、Xv6等系统源码，实现自己的LBA方式的磁盘访问。
> 在这个lab的`src`文件夹中，提供了makefile文件，同学们可以自行学习通过`make`的方法，更快捷地完成编译、运行任务。

##### 1.2

在Example1中，我们使用了LBA28的方式来读取硬盘。此时，我们只要给出逻辑扇区号即可，但需要手动去读取I/O端口。然而，BIOS提供了实模式下读取硬盘的中断，其不需要关心具体的I/O端口，只需要给出逻辑扇区号对应的磁头（Heads）、扇区（Sectors）和柱面（Cylinder）即可，又被称为CHS模式。现在，同学们需要将LBA28读取硬盘的方式换成CHS读取，同时给出逻辑扇区号向CHS的转换公式。最后说说你是怎么做的并提供结果截图。

参考资料：

- [CHS和LBA的换算小记](https://zhuanlan.zhihu.com/p/608292324)
- [int 13h中断](https://blog.csdn.net/brainkick/article/details/7583727)

其中，关键参数如下。

| 参数                             | 数值 |
| -------------------------------- | ---- |
| 驱动器号（DL寄存器）             | 80h  |
| 每磁道扇区数                     | 63   |
| 每柱面磁头数（每柱面总的磁道数） | 18   |

#### Assignment 2

复现Example 2，使用gdb或其他debug工具在进入保护模式的4个重要步骤上设置断点，并结合代码、寄存器的内容等来分析这4个步骤，最后附上结果截图。gdb的使用可以参考[appendix的“debug with gdb and qemu”部份](../appendix/debug_with_gdb_and_qemu/README.md)。
> 在这个lab的`src`文件夹中，同样提供了makefile文件，同学们可以自行学习通过`make`的方法，更快捷地完成debug任务。

> 可以通过查看GDT的内容，查看切换到保护模式的具体实现是怎么样的？在这个过程中，你也可以思考一下，Linux-0.11的存储方式，是小端存储还是大端存储呢？

#### Assignment 3

改造“Lab2-Assignment 4”为32位代码，即在加载到保护模式后执行自定义的汇编程序。

> 提示：
①在lab2中使用中断来实现功能的同学，现在会出错，为什么？怎么解决？
②在lab2中直接将字符输出到qemu显存的同学，如果直接复制粘贴代码，同样也会出错，为什么？怎么解决？

### 参考资料

- 《从实模式到保护模式》：第8.3.3节~8.3.5节，第11章，第12.4节。

## Lab4
### lab4 混合编程与中断

### 实验要求

> - DDL：2025年4月22号 23:59
> - 提交的内容：将**4个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab4-姓名-学号.zip**”，并交到[课程网站上](http://course.dds-sysu.tech/course/18/homework)
> - **材料的Example的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

#### Assignment 1 混合编程的基本思路

复现Example 1，结合具体的代码说明C代码调用汇编函数的语法和汇编代码调用C函数的语法。例如，结合代码说明`global`、`extern`关键字的作用，为什么C++的函数前需要加上`extern "C"`等， 结果截图并说说你是怎么做的。同时，学习make的使用，并用make来构建Example 1，结果截图并说说你是怎么做的。

#### Assignment 2 使用C/C++来编写内核

复现Example 2，在进入`setup_kernel`函数后，将输出 Hello World 改为输出你的学号，结果截图并说说你是怎么做的。

#### Assignment 3 中断的处理

> 在过去的一个多月里，经常有同学来问助教为什么自己的程序会出现段错误（Segmentaton Fault），助教觉得这是一个值得深刻思考的问题，决定继续~~用段错误折磨大家~~让大家深入学习段错误的成因，同时让大家稍微提前地学习到内存管理的部分相关知识。

请在`src/8`的基础上，仿照Example 3编写段错误的中断处理函数，助教已经`src/8/src/kernel/setup.cpp`中实现了对应的段错误触发语句，只要你正确实现段错误的中断处理并正确地在中断描述符中注册即可。

> 因为必须引入内存管理之后，才会有段错误（其实是**页面错误**），所以助教引入了一些lab7中的页面管理代码（memory.cpp等），同学们可以忽略这部分的代码，暂时不要求掌握。

**额外思考题**：请你使用尽可能多的方法触发段错误，并在你的实验报告里总结一下，引发段错误都有哪几种方式。

大家在实现完段错误的中断处理函数之后，可能会发现类似于“数组越界”这样的典型错误都无法引起段错误中断，这是“正常”现象，但请你想想，这是为什么？（提示：可以通过gdb等方法打印对应地址的值，并以此为角度思考为何尽管“越界”了，但仍然不中断报错）

所以在你的实验报告中，可以总结一下，哪些行为会真正地引起段错误中断；而哪些行为在理论上（以及在真正的C++程序中）会引起段错误，但却没有在你的内核中引起段错误中断。

下面简单地介绍一下页表机制，作为该思考题的提示。

设想你是精灵王国的国王，王国幅员辽阔，精灵们必须通过传送门（页表）回家。他们只需输入住处编号（虚拟地址），传送门便会根据映射关系，将他们送往真实的居所（物理地址）。例如，输入住处编号 0x114，传送门会指引他们到王国第 0x514 号土地上的房屋。然而，精灵们会生老病死、搬迁迁徙，住处编号与土地编号的对应关系也需不断更新，因此，国王必须及时登记新住址、注销旧住址，以确保传送门的映射始终正确。（即虚拟地址到物理地址的映射关系需实时更新）。

理解了上述的简单小故事，也就不难理解页表的思想了。我们回归页管理（可以查看一下`kernel/memory.cpp`的第28-33行，我们实际上对0-1MB的内存映射到页表的前256页（也即登记了这些住处），而其他地址还未进行注册，也即虚拟内存地址大于等于`0x100000`的，都没有登记，所以在`/kernel/setup.cpp`中的`*(int*)0x100000 = 1;`代码，实际上访问到了一个没有登记的住处编号（在开启页表后，我们就再也看不到物理地址了，这里的`0x100000`也是虚拟地址），所以导致了段错误（页面错误）。

#### Assignment 4 时钟中断

复现Example 4，仿照Example中使用C语言来实现时钟中断的例子，利用C/C++、 InterruptManager、STDIO或者还可以通过你自己封装的类来实现你的时钟中断处理过程，并通过这样的时钟中断，**使用C/C++语言**来复刻lab2的assignment 4 的字符回旋程序。将结果截图并说说你是怎么做的。注意，不可以使用纯汇编的方式来实现。

> 提示：在lab2和lab3实现字符回旋的时候，我们需要手动实现延时delay（无论是通过调用BIOS中断还是通过忙等的方式）。但是这里有了时钟中断之后，实际上时钟中断处理就自带了“延时”的功效了，所以我们便不必再实现delay函数。（PS：助教在前期验收的时候发现，有一些同学进入时钟中断后，直接打印了一圈的字符，这实际上是不符合该实验设计的初衷的，可以想想为什么，并进行修改）

## Lab5
###  内核线程

> 古今之成大事者，不惟有超世之才，亦必有坚韧不拔之志。

### 实验概述

在本次实验中，我们将会学习到C语言的可变参数机制的实现方法。在此基础上，我们会揭开可变参数背后的原理，进而实现可变参数机制。实现了可变参数机制后，我们将实现一个较为简单的printf函数。此后，我们可以同时使用printf和gdb来帮助我们debug。

本次实验另外一个重点是内核线程的实现，我们首先会定义线程控制块的数据结构——PCB。然后，我们会创建PCB，在PCB中放入线程执行所需的参数。最后，我们会实现基于时钟中断的时间片轮转(RR)调度算法。在这一部分中，我们需要重点理解`asm_switch_thread`是如何实现线程切换的，体会操作系统实现并发执行的原理。

### 实验要求

> - DDL：2023.5.6 23:59
> - 提交的内容：将**4个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab5-姓名-学号.zip**”，并交到课程网站上[http://course.dds-sysu.tech/course/18/homework]
> - **材料的Example的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

#### Assignment 1 printf的实现

学习可变参数机制，然后实现printf，你可以在材料中的printf上进行改进（提示：可以增加一些格式化输出类型，比如%f、%.f、%e等），或者从头开始实现自己的printf函数。结果截图并说说你是怎么做的。

#### Assignment 2 线程的实现

自行设计PCB，可以添加更多的属性，如优先级等，然后根据你的PCB来实现线程，演示执行结果。

#### Assignment 3 线程调度切换的秘密

操作系统的线程能够并发执行的秘密在于我们需要中断线程的执行，保存当前线程的状态，然后调度下一个线程上处理机，最后使被调度上处理机的线程从之前被中断点处恢复执行。现在，同学们可以亲手揭开这个秘密。

编写若干个线程函数，使用gdb跟踪`c_time_interrupt_handler`、`asm_switch_thread`等函数，观察线程切换前后栈、寄存器、PC等变化，结合gdb、材料中“线程的调度”的内容来跟踪并说明下面两个过程。

- 一个新创建的线程是如何被调度然后开始执行的。
- 一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理机后又是如何从被中断点开始执行的。

通过上面这个练习，同学们应该能够进一步理解操作系统是如何实现线程的并发执行的。

#### Assignment 4 调度算法的实现

在材料中，我们已经学习了如何使用时间片轮转算法来实现线程调度。但线程调度算法不止一种，例如

- 先来先服务。
- 最短作业（进程）优先。
- 响应比最高者优先算法。
- 优先级调度算法。
- 多级反馈队列调度算法。

此外，我们的调度算法还可以是抢占式的。

现在，同学们需要将线程调度算法修改为上面提到的算法或者是同学们自己设计的算法。然后，同学们需要自行编写测试样例来呈现你的算法实现的正确性和基本逻辑。最后，将结果截图并说说你是怎么做的。

参考资料：[https://zhuanlan.zhihu.com/p/97071815](https://gitee.com/link?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F97071815)

有时间的同学可以了解[ghOSt](https://github.com/google/ghost-userspace)

Tips：

- 先来先服务最简单。
- 有些调度算法的实现**可能需要**用到中断。

### 参考资料

- [可变参数函数详解](https://gitee.com/link?target=https%3A%2F%2Fwww.cnblogs.com%2Fclover-toeic%2Fp%2F3736748.html)
- 《操作系统真象还原》

## Lab6
### 并发与锁机制

### 实验概述

在本次实验中，我们首先使用硬件支持的原子指令来实现自旋锁SpinLock，自旋锁将成为实现线程互斥的有力工具。接着，我们使用SpinLock来实现信号量，最后我们使用SpinLock和信号量来给出两个实现线程互斥的解决方案。

### 实验要求

> - DDL：2025.05.20 23:59
> - 提交的内容：将**3个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab6-姓名-学号**”，并交到[课程网站上](http://course.dds-sysu.tech/course/18/homework)
> - **材料的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

#### Assignment 1 代码复现题

##### 1.1 代码复现

在本章中，我们已经实现了自旋锁和信号量机制。现在，同学们需要复现教程中的自旋锁和信号量的实现方法，并用分别使用二者解决一个同步互斥问题，如消失的芝士汉堡问题。最后，将结果截图并说说你是怎么做的。

##### 1.2 锁机制的实现

我们使用了原子指令`xchg`来实现自旋锁。但是，这种方法并不是唯一的。例如，x86指令中提供了另外一个原子指令`bts`和`lock`前缀等，这些指令也可以用来实现锁机制。现在，同学们需要结合自己所学的知识，实现一个与本教程的实现方式不完全相同的锁机制。最后，测试你实现的锁机制，将结果截图并说说你是怎么做的。

#### Assignment 2 读者-写者问题

读者-写者问题（Reader-Writer Problem） 是操作系统并发控制中经典的同步问题之一，涉及多个线程（或进程）对共享数据（如数据库、文件等）的访问。为了避免读到一些中间数据，所以在写者正在更新数据的时候，一般不允许其它读者/写者读取数据，所以需要进行同步；而读者并不会对数据进行修改，所以一般允许多个读者同时读数据（但是不能存在写者修改）。

##### 2.1 读者优先策略

请同学们思考读者-写者问题，并在本教程的代码环境下创建多个线程来模拟这个问题。你需要使用读者优先的策略来实现同步，并通过一定的样例设计来体现写者的“饥饿”。

> 请注意：为了体现写者的“饥饿”，你可能需要创建多个读者，让他们交错地进行读者任务（进入临界区、完成一段时间的任务、退出临界区、等待一段时间再进行下一次的读者任务），而**不应该让某个读者一直在临界区中占着不出来**。

> 提示：你可能需要用到随机数的生成，请你搜索相关资料，实现一个伪随机数生成器。

##### 2.2 写者优先策略（选做）

请你实现写者优先的策略来实现读者-写者问题的同步，并通过一定的样例设计来体现读者的“饥饿”。

> 为了能够体现写者优先策略的不同，你需要使用同一个样例（即你的线程函数需要是完全一致的（可以包含随机数模块）），分别使用读者优先策略和写者优先策略，并查看到确实可以出现两种不同的饥饿。

#### Assignment 3 哲学家就餐问题

假设有 5 个哲学家，他们的生活只是思考和吃饭。这些哲学家共用一个圆桌，每位都有一把椅子。在桌子中央有五碗米饭，并在桌子上放着 5 根筷子。

![哲学家就餐问题](./gallery/哲学家就餐问题.jpeg)

当一位哲学家思考时，他与其他同事不交流。时而，他会感到饥饿，并试图拿起与他相近的两根筷子（筷子在他和他的左或右邻居之间）。一个哲学家一次只能拿起一根筷子。显然，他不能从其他哲学家手里拿走筷子。当一个饥饿的哲学家同时拥有两根筷子时，他就能吃。在吃完后，他会放下两根筷子，并开始思考。

##### 3.1 初步解决方法

同学们需要在本教程的代码环境下，创建多个线程来模拟哲学家就餐的场景。然后，同学们需要结合信号量来实现理论课教材中给出的关于哲学家就餐问题的方法。最后，将结果截图并说说你是怎么做的。

##### 3.2 死锁解决方法

虽然3.1的解决方案保证两个邻居不能同时进食，但是它可能导致死锁。现在，同学们需要想办法将死锁的场景演示出来。然后，提出一种解决死锁的方法并实现之。最后，将结果截图并说说你是怎么做的。

## Lab7
### 实验要求

> - DDL：2025.6.3 23:59:59
> - 提交的内容：将**4个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab7-姓名-学号**”，并交到课程网站上[http://course.dds-sysu.tech/course/18/homework]
> - **材料的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

#### Assignment 1

复现参考代码，实现二级分页机制，并能够在虚拟地址空间中进行内存管理，包括内存的申请和释放等，截图并给出过程解释。

#### Assignment 2

参照理论课上的学习的物理内存分配算法如first-fit, best-fit等实现动态分区算法等，或者自行提出自己的算法。

#### Assignment 3

参照理论课上虚拟内存管理的页面置换算法如FIFO、LRU等，实现页面置换，也可以提出自己的算法。

#### Assignment 4

复现“虚拟页内存管理”一节的代码，完成如下要求。

- 结合代码分析虚拟页内存分配的三步过程和虚拟页内存释放。
- 构造测试例子来分析虚拟页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测试。否则，结合测例简要分析虚拟页内存管理的实现的正确性。
- （**不做要求，对评分没有影响**）如果你有想法，可以在自己的理解的基础上，参考ucore，《操作系统真象还原》，《一个操作系统的实现》等资料来实现自己的虚拟页内存管理。在完成之后，你需要指明相比较于本教程，你的实现的虚拟页内存管理的特点所在。

## Lab8
### 实验要求

> - DDL：2025年06月17号 23:59
> - 提交的内容：将**3个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab8-姓名-学号**”，并交到课程网站上[http://course.dds-sysu.tech/course/18/homework]
> - **材料的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

#### Assignment 1 系统调用

编写一个系统调用，然后在进程中调用之，根据结果回答以下问题。

- 展现系统调用执行结果的正确性，结果截图并并说说你的实现思路。
- 请根据gdb来分析执行系统调用后的栈的变化情况。
- 请根据gdb来说明TSS在系统调用执行过程中的作用。

#### Assignment 2 Fork的奥秘

实现fork函数，并回答以下问题。

- 请根据代码逻辑和执行结果来分析fork实现的基本思路。
- 从子进程第一次被调度执行时开始，逐步跟踪子进程的执行流程一直到子进程从`fork`返回，根据gdb来分析子进程的跳转地址、数据寄存器和段寄存器的变化。同时，比较上述过程和父进程执行完`ProgramManager::fork`后的返回过程的异同。
- 请根据代码逻辑和gdb来解释fork是如何保证子进程的`fork`返回值是0，而父进程的`fork`返回值是子进程的pid。

#### Assignment 3 哼哈二将 wait & exit

实现wait函数和exit函数，并回答以下问题。

- 请结合代码逻辑和具体的实例来分析exit的执行过程。
- 请分析进程退出后能够隐式地调用exit和此时的exit返回值是0的原因。
- 请结合代码逻辑和具体的实例来分析wait的执行过程。
- 如果一个父进程先于子进程退出，那么子进程在退出之前会被称为孤儿进程。子进程在退出后，从状态被标记为`DEAD`开始到被回收，子进程会被称为僵尸进程。请对代码做出修改，实现回收僵尸进程的有效方法。

## Lab9
### 第八章 Course Projects

> 更喜岷山千里雪，三军过后尽开颜。

我们终于来到了本学期实验课的最后一次实验，在本章中，同学们可以从以下项目中选出若干个自己喜欢的项目来实现。

### Project 1 虚拟内存的完善

通过分页机制，我们实现了内存的虚拟化，从而使得程序可以看到比实际的物理内存更大的虚拟内存。虚拟内存另外一个重要的组成部分是页换入换出机制，页换入换出的解释如下。

当内存紧张的时候，我们不得不将一些物理页换出内存，存放到磁盘上，这被称为页的换出。当程序需要使用被换出的页时，程序会产生一个缺页中断。此时，缺页中断处理函数根据页面置换算法将其他某些页换出，然后将程序需要的页从磁盘加载到内存，并修改页表，使得页表重新指向被重新加载到内存的页。这个过程被称为页的换入。

为了简便起见，我们并没有实现页换入换出机制。现在，同学们需要在自己本学期的实验基础上，实现页换入换出机制。在实现了页换入换出机制后，同学们需要自行提供测例来测试页的换出和页的换入。根据测试方法和输出结果来解释自己程序的正确性。最后将结果截图并说说你是怎么做的。

### Project 2 malloc/free的实现

我们已经实现了以页为粒度的动态内存分配和释放。但是，我们在程序中使用的往往是以字节为粒度的动态内存管理机制，即我们可以分配和释放任意字节长度的内存。

在本项目中，同学们需要实现系统调用malloc和free。malloc用于分配任意字节的内存，free用于释放任意字节的内存。在实现了malloc和free后，同学们需要自行提供测例来测试malloc和free。根据测试方法和输出结果来解释自己程序的正确性。最后将结果截图并说说你是怎么做的。

### Project 3 文件系统的实现

我们已经知道，内存是易失的，磁盘是非易失的。有时我们需要将数据从内存持久化到磁盘上。此时，我们需要提供一种结构来有效管理磁盘上的数据，这种结构被称为文件系统。例如，我们将存储到磁盘上的数据称为一个个“文件”、“文件”之间的结构和组成关系被称为“目录”、文件系统提供了“路径”使得我们容易标记磁盘上的文件……总而言之，文件系统大大方便了我们对磁盘上的数据的管理。

在本项目中，同学们可以参考经典的文件系统来设计自己的文件系统，如FAT、NTFS、EXT等，实现基本的文件系统功能。在实现文件系统后，同学们需要自行提供测例来测试malloc和free。根据测试方法和输出结果来解释文件系统的正确性。最后将结果截图并说说你是怎么做的。

### Project 4 Shell的实现

虽然我们已经实现了操作系统的许多基本概念，但是我们的操作系统并不能接受和处理我们的命令。在Linux系统中，我们可以很方便地在Terminal下输入并执行我们的命令，如`cd`、`ls`等，这个用于解释和处理用户命令的Terminal被称为Shell。

现在，同学们需要在本学期自己的实验基础上实现Shell，同学们的Shell应该具有以下基本功能。

+ 实现键盘输入并能够解析和处理用户输入的命令。
+ 在实现Project 3的基础上，实现从文件系统中加载程序到内存、然后解析ELF文件、最后创建进程运行这个程序。

在实现Shell后，同学们需要自行提供测例来测试你的Shell。根据测试方法和输出结果来解释你的Shell的正确性。最后将结果截图并说说你是怎么做的。

### Project 5 CopyOnWrite

在我们的fork实现当中，我们会复制父进程的所有资源到子进程中。这样的做法虽然简单，但是开销较大。注意到如下特点

+ 父进程中有些资源是只读的，并不会做修改。因此任何时刻，父子进程的只读资源都是相同的。因此父子进程的只读资源可以共享。
+ 父进程的有些资源在子进程中可能不会被再次用到，或者是暂时不会被用到。

因此，为了减少资源的开销，我们可以实现copy-on-write（写时复制）机制。在写时复制机制中，fork函数不会为子进程复制任何父进程任何物理页，而是父进程共享相同的物理空间，父子共享的部分被标记为只读的。当父/子进程需要修改共享的内容的时候，会产生一个中断。然后，这个中断处理函数会为子进程分配物理空间，然后将需要修改的数据复制到刚刚为子进程分配的物理空间中。中断处理完成后，父/子进程才会修改刚刚需要的数据。

现在，同学们需要在本学期自己的实验基础上实现基于copy-on-write机制的fork函数。在实现copy-on-write后，同学们需要自行提供测例来测试你的copy-on-write。根据测试方法和输出结果来解释你的copy-on-write的正确性。最后将结果截图并说说你是怎么做的。

### Project 6 另辟蹊径

考虑到同学们可能会有其他的想法，同学们大可天马行空，另辟蹊径。project 6只为同学们提供一些探索思路。

本教程创始于2021年春季中山大学计算机学院操作系统课程，在陈鹏飞老师的统一指导下完成。时间仓促，在本教程中会存在许许多多的意想不到的问题，例如对某些概念解释不清、代码中存在bug、实验安排不不合理等。同时，本教程为了简化，省去了许多本教程认为不是必须的操作系统实现的细节。因此，同学们可以结合自己的实验过程，参考ucore、《操作系统真象还原》、《一个操作系统的实现》等来完善本教程。

本教程使用C/C++和x86汇编来实现。但是，C/C++和x86汇编已有数十年的历史。如今，Rust语言和arm处理器方兴未艾。同学们可以结合rust语言和arm处理器来重构本教程的代码。同学们可以使用rust+x86，C/C++ + arm，rust+arm的方式来实现。

同学们可以考虑你实现的操作系统是否可以在真实的硬件上执行，例如在树莓派中执行、使用U盘在你的电脑上启动等。

本教程是在32位保护模式下实现的，同学们可以探索64位操作系统的实现。

……







 
